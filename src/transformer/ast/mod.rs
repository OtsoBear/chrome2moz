//! AST-based JavaScript/TypeScript transformer modules
//! 
//! Production-grade AST transformation with native TypeScript support.

pub mod parser;
pub mod visitor;
pub mod codegen;
pub mod scope;
pub mod module_detector;
pub mod polyfill;
pub mod callback;
pub mod execute_script;

pub use parser::AstParser;
pub use visitor::ChromeTransformVisitor;
pub use codegen::CodeGenerator;
pub use scope::ScopeAnalyzer;
pub use module_detector::{ModuleDetector, ModuleType};
pub use polyfill::PolyfillInjector;
pub use callback::CallbackTransformer;
pub use execute_script::ExecuteScriptTransformer;

use anyhow::Result;
use std::path::Path;
use swc_core::ecma::ast::{Module, ModuleItem, Stmt, Expr, Callee};
use swc_core::ecma::visit::VisitMutWith;
use crate::utils::replace_chrome_urls;

/// AST-based transformer for JavaScript/TypeScript
pub struct AstTransformer {
    parser: AstParser,
    codegen: CodeGenerator,
    last_generated_handlers: Vec<String>,
}

impl AstTransformer {
    pub fn new() -> Self {
        Self {
            parser: AstParser::new(),
            codegen: CodeGenerator::new(),
            last_generated_handlers: Vec::new(),
        }
    }
    
    /// Get handlers generated during the last transform
    pub fn get_generated_handlers(&self) -> Vec<String> {
        self.last_generated_handlers.clone()
    }
    
    /// Transform JavaScript/TypeScript code from Chrome to Firefox compatibility
    pub fn transform(&mut self, code: &str, path: &Path) -> Result<String> {
        // 1. Parse the code into an AST
        let mut module = self.parser.parse(code, path)?;
        
        // 2. Detect module type for polyfill injection
        let _module_type = ModuleDetector::detect(&module);
        
        // 3. Strip TypeScript if necessary
        if path.extension().map_or(false, |e| e == "ts" || e == "tsx") {
            module = self.strip_typescript(module)?;
        }
        
        // 4. Remove importScripts() calls (Firefox event pages don't support them)
        module.body.retain(|item| {
            if let ModuleItem::Stmt(Stmt::Expr(expr_stmt)) = item {
                if let Expr::Call(call) = &*expr_stmt.expr {
                    if let Callee::Expr(callee) = &call.callee {
                        if let Expr::Ident(ident) = &**callee {
                            if &*ident.sym == "importScripts" {
                                return false; // Remove this item
                            }
                        }
                    }
                }
            }
            true // Keep this item
        });
        
        // 5. Apply Chrome → Browser transformations
        let mut visitor = ChromeTransformVisitor::new();
        self.apply_visitor(&mut module, &mut visitor);
        
        // 6. Fix executeScript 'function' → 'func' for Firefox
        let mut exec_transformer = ExecuteScriptTransformer::new();
        module.visit_mut_with(&mut exec_transformer);
        
        if exec_transformer.transforms_count() > 0 {
            println!("🔧 Fixed {} executeScript call(s): renamed 'function' → 'func' for Firefox",
                exec_transformer.transforms_count());
        }
        
        if !exec_transformer.warnings().is_empty() {
            for warning in exec_transformer.warnings() {
                eprintln!("⚠️  {}", warning);
            }
        }
        
        // 7. Transform callbacks to promises
        let mut callback_transformer = CallbackTransformer::new();
        module.visit_mut_with(&mut callback_transformer);
        
        // 9. Inject polyfill based on module type
        // TODO: Fix polyfill injection - currently breaks browser global files
        // let polyfill_injector = PolyfillInjector::new();
        // polyfill_injector.inject(&mut module, module_type);
        
        // 10. Generate the transformed code
        let code = self.codegen.generate(&module)?;
        
        // 11. Apply chrome:// URL replacement (regex-based, works on all text)
        let code = replace_chrome_urls(&code);
        
        Ok(code)
    }
    
    /// Transform with handler injection for content scripts
    pub fn transform_with_handlers(&mut self, code: &str, path: &Path, handlers_to_inject: &[String]) -> Result<String> {
        // Parse and transform normally
        let transformed = self.transform(code, path)?;
        
        // If there are handlers to inject, add them at the top
        if !handlers_to_inject.is_empty() {
            let mut result = String::new();
            result.push_str("// ===== AUTO-GENERATED HANDLERS FOR executeScript FIX =====\n");
            result.push_str("// These handlers were automatically generated by chrome2moz converter\n\n");
            
            for handler in handlers_to_inject {
                result.push_str(handler);
                result.push_str("\n\n");
            }
            
            result.push_str("// ===== END AUTO-GENERATED HANDLERS =====\n\n");
            result.push_str(&transformed);
            
            Ok(result)
        } else {
            Ok(transformed)
        }
    }
    
    fn strip_typescript(&self, module: Module) -> Result<Module> {
        use swc_core::ecma::transforms::typescript::strip;
        use swc_core::ecma::visit::FoldWith;
        use swc_core::common::GLOBALS;
        use swc_core::ecma::ast::Program;
        
        GLOBALS.set(&Default::default(), || {
            // Wrap in Program for the transform
            let program = Program::Module(module);
            
            // Create TypeScript stripper with default config
            let mut pass = strip(Default::default());
            
            // Apply the transform
            let program = program.fold_with(&mut pass);
            
            // Extract module back
            match program {
                Program::Module(m) => Ok(m),
                Program::Script(s) => {
                    // Convert script to module if needed
                    Ok(Module {
                        span: s.span,
                        body: s.body.into_iter().map(|stmt| {
                            swc_core::ecma::ast::ModuleItem::Stmt(stmt)
                        }).collect(),
                        shebang: s.shebang,
                    })
                }
            }
        })
    }
    
    fn apply_visitor(&self, module: &mut Module, visitor: &mut ChromeTransformVisitor) {
        use swc_core::ecma::visit::VisitMutWith;
        use swc_core::common::GLOBALS;
        
        GLOBALS.set(&Default::default(), || {
            module.visit_mut_with(visitor);
        });
    }
}

impl Default for AstTransformer {
    fn default() -> Self {
        Self::new()
    }
}